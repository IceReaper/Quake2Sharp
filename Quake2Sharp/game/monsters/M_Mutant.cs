/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
namespace Quake2Sharp.game.monsters;

using adapters;
using client;
using types;
using util;

public class M_Mutant
{
	//	This file generated by ModelGen - Do NOT Modify
	public static readonly int FRAME_attack01 = 0;
	public static readonly int FRAME_attack02 = 1;
	public static readonly int FRAME_attack03 = 2;
	public static readonly int FRAME_attack04 = 3;
	public static readonly int FRAME_attack05 = 4;
	public static readonly int FRAME_attack06 = 5;
	public static readonly int FRAME_attack07 = 6;
	public static readonly int FRAME_attack08 = 7;
	public static readonly int FRAME_attack09 = 8;
	public static readonly int FRAME_attack10 = 9;
	public static readonly int FRAME_attack11 = 10;
	public static readonly int FRAME_attack12 = 11;
	public static readonly int FRAME_attack13 = 12;
	public static readonly int FRAME_attack14 = 13;
	public static readonly int FRAME_attack15 = 14;
	public static readonly int FRAME_death101 = 15;
	public static readonly int FRAME_death102 = 16;
	public static readonly int FRAME_death103 = 17;
	public static readonly int FRAME_death104 = 18;
	public static readonly int FRAME_death105 = 19;
	public static readonly int FRAME_death106 = 20;
	public static readonly int FRAME_death107 = 21;
	public static readonly int FRAME_death108 = 22;
	public static readonly int FRAME_death109 = 23;
	public static readonly int FRAME_death201 = 24;
	public static readonly int FRAME_death202 = 25;
	public static readonly int FRAME_death203 = 26;
	public static readonly int FRAME_death204 = 27;
	public static readonly int FRAME_death205 = 28;
	public static readonly int FRAME_death206 = 29;
	public static readonly int FRAME_death207 = 30;
	public static readonly int FRAME_death208 = 31;
	public static readonly int FRAME_death209 = 32;
	public static readonly int FRAME_death210 = 33;
	public static readonly int FRAME_pain101 = 34;
	public static readonly int FRAME_pain102 = 35;
	public static readonly int FRAME_pain103 = 36;
	public static readonly int FRAME_pain104 = 37;
	public static readonly int FRAME_pain105 = 38;
	public static readonly int FRAME_pain201 = 39;
	public static readonly int FRAME_pain202 = 40;
	public static readonly int FRAME_pain203 = 41;
	public static readonly int FRAME_pain204 = 42;
	public static readonly int FRAME_pain205 = 43;
	public static readonly int FRAME_pain206 = 44;
	public static readonly int FRAME_pain301 = 45;
	public static readonly int FRAME_pain302 = 46;
	public static readonly int FRAME_pain303 = 47;
	public static readonly int FRAME_pain304 = 48;
	public static readonly int FRAME_pain305 = 49;
	public static readonly int FRAME_pain306 = 50;
	public static readonly int FRAME_pain307 = 51;
	public static readonly int FRAME_pain308 = 52;
	public static readonly int FRAME_pain309 = 53;
	public static readonly int FRAME_pain310 = 54;
	public static readonly int FRAME_pain311 = 55;
	public static readonly int FRAME_run03 = 56;
	public static readonly int FRAME_run04 = 57;
	public static readonly int FRAME_run05 = 58;
	public static readonly int FRAME_run06 = 59;
	public static readonly int FRAME_run07 = 60;
	public static readonly int FRAME_run08 = 61;
	public static readonly int FRAME_stand101 = 62;
	public static readonly int FRAME_stand102 = 63;
	public static readonly int FRAME_stand103 = 64;
	public static readonly int FRAME_stand104 = 65;
	public static readonly int FRAME_stand105 = 66;
	public static readonly int FRAME_stand106 = 67;
	public static readonly int FRAME_stand107 = 68;
	public static readonly int FRAME_stand108 = 69;
	public static readonly int FRAME_stand109 = 70;
	public static readonly int FRAME_stand110 = 71;
	public static readonly int FRAME_stand111 = 72;
	public static readonly int FRAME_stand112 = 73;
	public static readonly int FRAME_stand113 = 74;
	public static readonly int FRAME_stand114 = 75;
	public static readonly int FRAME_stand115 = 76;
	public static readonly int FRAME_stand116 = 77;
	public static readonly int FRAME_stand117 = 78;
	public static readonly int FRAME_stand118 = 79;
	public static readonly int FRAME_stand119 = 80;
	public static readonly int FRAME_stand120 = 81;
	public static readonly int FRAME_stand121 = 82;
	public static readonly int FRAME_stand122 = 83;
	public static readonly int FRAME_stand123 = 84;
	public static readonly int FRAME_stand124 = 85;
	public static readonly int FRAME_stand125 = 86;
	public static readonly int FRAME_stand126 = 87;
	public static readonly int FRAME_stand127 = 88;
	public static readonly int FRAME_stand128 = 89;
	public static readonly int FRAME_stand129 = 90;
	public static readonly int FRAME_stand130 = 91;
	public static readonly int FRAME_stand131 = 92;
	public static readonly int FRAME_stand132 = 93;
	public static readonly int FRAME_stand133 = 94;
	public static readonly int FRAME_stand134 = 95;
	public static readonly int FRAME_stand135 = 96;
	public static readonly int FRAME_stand136 = 97;
	public static readonly int FRAME_stand137 = 98;
	public static readonly int FRAME_stand138 = 99;
	public static readonly int FRAME_stand139 = 100;
	public static readonly int FRAME_stand140 = 101;
	public static readonly int FRAME_stand141 = 102;
	public static readonly int FRAME_stand142 = 103;
	public static readonly int FRAME_stand143 = 104;
	public static readonly int FRAME_stand144 = 105;
	public static readonly int FRAME_stand145 = 106;
	public static readonly int FRAME_stand146 = 107;
	public static readonly int FRAME_stand147 = 108;
	public static readonly int FRAME_stand148 = 109;
	public static readonly int FRAME_stand149 = 110;
	public static readonly int FRAME_stand150 = 111;
	public static readonly int FRAME_stand151 = 112;
	public static readonly int FRAME_stand152 = 113;
	public static readonly int FRAME_stand153 = 114;
	public static readonly int FRAME_stand154 = 115;
	public static readonly int FRAME_stand155 = 116;
	public static readonly int FRAME_stand156 = 117;
	public static readonly int FRAME_stand157 = 118;
	public static readonly int FRAME_stand158 = 119;
	public static readonly int FRAME_stand159 = 120;
	public static readonly int FRAME_stand160 = 121;
	public static readonly int FRAME_stand161 = 122;
	public static readonly int FRAME_stand162 = 123;
	public static readonly int FRAME_stand163 = 124;
	public static readonly int FRAME_stand164 = 125;
	public static readonly int FRAME_walk01 = 126;
	public static readonly int FRAME_walk02 = 127;
	public static readonly int FRAME_walk03 = 128;
	public static readonly int FRAME_walk04 = 129;
	public static readonly int FRAME_walk05 = 130;
	public static readonly int FRAME_walk06 = 131;
	public static readonly int FRAME_walk07 = 132;
	public static readonly int FRAME_walk08 = 133;
	public static readonly int FRAME_walk09 = 134;
	public static readonly int FRAME_walk10 = 135;
	public static readonly int FRAME_walk11 = 136;
	public static readonly int FRAME_walk12 = 137;
	public static readonly int FRAME_walk13 = 138;
	public static readonly int FRAME_walk14 = 139;
	public static readonly int FRAME_walk15 = 140;
	public static readonly int FRAME_walk16 = 141;
	public static readonly int FRAME_walk17 = 142;
	public static readonly int FRAME_walk18 = 143;
	public static readonly int FRAME_walk19 = 144;
	public static readonly int FRAME_walk20 = 145;
	public static readonly int FRAME_walk21 = 146;
	public static readonly int FRAME_walk22 = 147;
	public static readonly int FRAME_walk23 = 148;
	public static readonly float MODEL_SCALE = 1.000000f;
	private static int sound_swing;
	private static int sound_hit;
	private static int sound_hit2;
	private static int sound_death;
	private static int sound_idle;
	private static int sound_pain1;
	private static int sound_pain2;
	private static int sound_sight;
	private static int sound_search;
	private static int sound_step1;
	private static int sound_step2;
	private static int sound_step3;
	private static int sound_thud;

	//
	//	SOUNDS
	//
	private static readonly EntThinkAdapter mutant_step = new("mutant_step", self =>
	{
		int n;
		n = (Lib.rand() + 1) % 3;

		if (n == 0)
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_step1, 1, Defines.ATTN_NORM, 0);
		else if (n == 1)
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_step2, 1, Defines.ATTN_NORM, 0);
		else
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_step3, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	private static readonly EntInteractAdapter mutant_sight = new("mutant_sight", (self, other) =>
	{
		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_sight, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	private static readonly EntThinkAdapter mutant_search = new("mutant_search", self =>
	{
		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_search, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	private static EntThinkAdapter mutant_swing = new("mutant_swing", self =>
	{
		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_swing, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	//
	//	STAND
	//

	private static readonly mframe_t[] mutant_frames_stand =
	{
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// 10)

		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// 20)

		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// 30)

		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// 40)

		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// 50)

		new(GameAI.ai_stand, 0, null)
	};

	private static readonly mmove_t mutant_move_stand = new(M_Mutant.FRAME_stand101, M_Mutant.FRAME_stand151, M_Mutant.mutant_frames_stand, null);

	private static readonly EntThinkAdapter mutant_stand = new("mutant_stand", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_stand;

		return true;
	});

	//
	//	IDLE
	//

	private static readonly EntThinkAdapter mutant_idle_loop = new("mutant_idle_loop", self =>
	{
		if (Lib.random() < 0.75)
			self.monsterinfo.nextframe = M_Mutant.FRAME_stand155;

		return true;
	});

	private static readonly mframe_t[] mutant_frames_idle =
	{
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),

		// scratch loop start
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, M_Mutant.mutant_idle_loop),

		// scratch loop end
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null),
		new(GameAI.ai_stand, 0, null)
	};

	private static readonly mmove_t mutant_move_idle =
		new(M_Mutant.FRAME_stand152, M_Mutant.FRAME_stand164, M_Mutant.mutant_frames_idle, M_Mutant.mutant_stand);

	private static readonly EntThinkAdapter mutant_idle = new("mutant_idle", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_idle;
		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_idle, 1, Defines.ATTN_IDLE, 0);

		return true;
	});

	//
	//	WALK
	//

	private static readonly mframe_t[] mutant_frames_walk =
	{
		new(GameAI.ai_walk, 3, null),
		new(GameAI.ai_walk, 1, null),
		new(GameAI.ai_walk, 5, null),
		new(GameAI.ai_walk, 10, null),
		new(GameAI.ai_walk, 13, null),
		new(GameAI.ai_walk, 10, null),
		new(GameAI.ai_walk, 0, null),
		new(GameAI.ai_walk, 5, null),
		new(GameAI.ai_walk, 6, null),
		new(GameAI.ai_walk, 16, null),
		new(GameAI.ai_walk, 15, null),
		new(GameAI.ai_walk, 6, null)
	};

	private static readonly mmove_t mutant_move_walk = new(M_Mutant.FRAME_walk05, M_Mutant.FRAME_walk16, M_Mutant.mutant_frames_walk, null);

	private static readonly EntThinkAdapter mutant_walk_loop = new("mutant_walk_loop", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_walk;

		return true;
	});

	private static readonly mframe_t[] mutant_frames_start_walk =
	{
		new(GameAI.ai_walk, 5, null), new(GameAI.ai_walk, 5, null), new(GameAI.ai_walk, -2, null), new(GameAI.ai_walk, 1, null)
	};

	private static readonly mmove_t mutant_move_start_walk =
		new(M_Mutant.FRAME_walk01, M_Mutant.FRAME_walk04, M_Mutant.mutant_frames_start_walk, M_Mutant.mutant_walk_loop);

	private static readonly EntThinkAdapter mutant_walk = new("mutant_walk", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_start_walk;

		return true;
	});

	//
	//	RUN
	//

	private static readonly mframe_t[] mutant_frames_run =
	{
		new(GameAI.ai_run, 40, null),
		new(GameAI.ai_run, 40, M_Mutant.mutant_step),
		new(GameAI.ai_run, 24, null),
		new(GameAI.ai_run, 5, M_Mutant.mutant_step),
		new(GameAI.ai_run, 17, null),
		new(GameAI.ai_run, 10, null)
	};

	private static readonly mmove_t mutant_move_run = new(M_Mutant.FRAME_run03, M_Mutant.FRAME_run08, M_Mutant.mutant_frames_run, null);

	private static readonly EntThinkAdapter mutant_run = new("mutant_run", self =>
	{
		if ((self.monsterinfo.aiflags & Defines.AI_STAND_GROUND) != 0)
			self.monsterinfo.currentmove = M_Mutant.mutant_move_stand;
		else
			self.monsterinfo.currentmove = M_Mutant.mutant_move_run;

		return true;
	});

	//
	//	MELEE
	//

	private static readonly EntThinkAdapter mutant_hit_left = new("mutant_hit_left", self =>
	{
		float[] aim = { 0, 0, 0 };

		Math3D.VectorSet(aim, Defines.MELEE_DISTANCE, self.mins[0], 8);

		if (GameWeapon.fire_hit(self, aim, 10 + Lib.rand() % 5, 100))
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Mutant.sound_hit, 1, Defines.ATTN_NORM, 0);
		else
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Mutant.sound_swing, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	private static readonly EntThinkAdapter mutant_hit_right = new("mutant_hit_right", self =>
	{
		float[] aim = { 0, 0, 0 };

		Math3D.VectorSet(aim, Defines.MELEE_DISTANCE, self.maxs[0], 8);

		if (GameWeapon.fire_hit(self, aim, 10 + Lib.rand() % 5, 100))
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Mutant.sound_hit2, 1, Defines.ATTN_NORM, 0);
		else
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Mutant.sound_swing, 1, Defines.ATTN_NORM, 0);

		return true;
	});

	private static readonly EntThinkAdapter mutant_check_refire = new("mutant_check_refire", self =>
	{
		if (null == self.enemy || !self.enemy.inuse || self.enemy.health <= 0)
			return true;

		if ((GameBase.skill.value == 3 && Lib.random() < 0.5) || GameUtil.range(self, self.enemy) == Defines.RANGE_MELEE)
			self.monsterinfo.nextframe = M_Mutant.FRAME_attack09;

		return true;
	});

	private static readonly mframe_t[] mutant_frames_attack =
	{
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 0, M_Mutant.mutant_hit_left),
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 0, M_Mutant.mutant_hit_right),
		new(GameAI.ai_charge, 0, M_Mutant.mutant_check_refire)
	};

	private static readonly mmove_t mutant_move_attack =
		new(M_Mutant.FRAME_attack09, M_Mutant.FRAME_attack15, M_Mutant.mutant_frames_attack, M_Mutant.mutant_run);

	private static readonly EntThinkAdapter mutant_melee = new("mutant_melee", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_attack;

		return true;
	});

	//
	//	ATTACK
	//

	private static readonly EntTouchAdapter mutant_jump_touch = new("mutant_jump_touch", (self, other, plane, surf) =>
	{
		if (self.health <= 0)
		{
			self.touch = null;

			return;
		}

		if (other.takedamage != 0)
		{
			if (Math3D.VectorLength(self.velocity) > 400)
			{
				float[] point = { 0, 0, 0 };
				float[] normal = { 0, 0, 0 };
				int damage;

				Math3D.VectorCopy(self.velocity, normal);
				Math3D.VectorNormalize(normal);
				Math3D.VectorMA(self.s.origin, self.maxs[0], normal, point);
				damage = (int)(40 + 10 * Lib.random());
				GameCombat.T_Damage(other, self, self, self.velocity, point, normal, damage, damage, 0, Defines.MOD_UNKNOWN);
			}
		}

		if (!M.M_CheckBottom(self))
		{
			if (self.groundentity != null)
			{
				self.monsterinfo.nextframe = M_Mutant.FRAME_attack02;
				self.touch = null;
			}

			return;
		}

		self.touch = null;
	});

	private static readonly EntThinkAdapter mutant_jump_takeoff = new("mutant_jump_takeoff", self =>
	{
		float[] forward = { 0, 0, 0 };

		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_sight, 1, Defines.ATTN_NORM, 0);
		Math3D.AngleVectors(self.s.angles, forward, null, null);
		self.s.origin[2] += 1;
		Math3D.VectorScale(forward, 600, self.velocity);
		self.velocity[2] = 250;
		self.groundentity = null;
		self.monsterinfo.aiflags |= Defines.AI_DUCKED;
		self.monsterinfo.attack_finished = GameBase.level.time + 3;
		self.touch = M_Mutant.mutant_jump_touch;

		return true;
	});

	private static readonly EntThinkAdapter mutant_check_landing = new("mutant_check_landing", self =>
	{
		if (self.groundentity != null)
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Mutant.sound_thud, 1, Defines.ATTN_NORM, 0);
			self.monsterinfo.attack_finished = 0;
			self.monsterinfo.aiflags &= ~Defines.AI_DUCKED;

			return true;
		}

		if (GameBase.level.time > self.monsterinfo.attack_finished)
			self.monsterinfo.nextframe = M_Mutant.FRAME_attack02;
		else
			self.monsterinfo.nextframe = M_Mutant.FRAME_attack05;

		return true;
	});

	private static readonly mframe_t[] mutant_frames_jump =
	{
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 17, null),
		new(GameAI.ai_charge, 15, M_Mutant.mutant_jump_takeoff),
		new(GameAI.ai_charge, 15, null),
		new(GameAI.ai_charge, 15, M_Mutant.mutant_check_landing),
		new(GameAI.ai_charge, 0, null),
		new(GameAI.ai_charge, 3, null),
		new(GameAI.ai_charge, 0, null)
	};

	private static readonly mmove_t mutant_move_jump =
		new(M_Mutant.FRAME_attack01, M_Mutant.FRAME_attack08, M_Mutant.mutant_frames_jump, M_Mutant.mutant_run);

	private static readonly EntThinkAdapter mutant_jump = new("mutant_jump", self =>
	{
		self.monsterinfo.currentmove = M_Mutant.mutant_move_jump;

		return true;
	});

	//
	//	CHECKATTACK
	//
	private static readonly EntThinkAdapter mutant_check_melee = new("mutant_check_melee", self =>
	{
		if (GameUtil.range(self, self.enemy) == Defines.RANGE_MELEE)
			return true;

		return false;
	});

	private static readonly EntThinkAdapter mutant_check_jump = new("mutant_check_jump", self =>
	{
		float[] v = { 0, 0, 0 };
		float distance;

		if (self.absmin[2] > self.enemy.absmin[2] + 0.75 * self.enemy.size[2])
			return false;

		if (self.absmax[2] < self.enemy.absmin[2] + 0.25 * self.enemy.size[2])
			return false;

		v[0] = self.s.origin[0] - self.enemy.s.origin[0];
		v[1] = self.s.origin[1] - self.enemy.s.origin[1];
		v[2] = 0;
		distance = Math3D.VectorLength(v);

		if (distance < 100)
			return false;

		if (distance > 100)
		{
			if (Lib.random() < 0.9)
				return false;
		}

		return true;
	});

	private static readonly EntThinkAdapter mutant_checkattack = new("mutant_checkattack", self =>
	{
		if (null == self.enemy || self.enemy.health <= 0)
			return false;

		if (M_Mutant.mutant_check_melee.think(self))
		{
			self.monsterinfo.attack_state = Defines.AS_MELEE;

			return true;
		}

		if (M_Mutant.mutant_check_jump.think(self))
		{
			self.monsterinfo.attack_state = Defines.AS_MISSILE;

			// FIXME play a jump sound here
			return true;
		}

		return false;
	});

	//
	//	PAIN
	//

	private static readonly mframe_t[] mutant_frames_pain1 =
	{
		new(GameAI.ai_move, 4, null),
		new(GameAI.ai_move, -3, null),
		new(GameAI.ai_move, -8, null),
		new(GameAI.ai_move, 2, null),
		new(GameAI.ai_move, 5, null)
	};

	private static readonly mmove_t mutant_move_pain1 =
		new(M_Mutant.FRAME_pain101, M_Mutant.FRAME_pain105, M_Mutant.mutant_frames_pain1, M_Mutant.mutant_run);

	private static readonly mframe_t[] mutant_frames_pain2 =
	{
		new(GameAI.ai_move, -24, null),
		new(GameAI.ai_move, 11, null),
		new(GameAI.ai_move, 5, null),
		new(GameAI.ai_move, -2, null),
		new(GameAI.ai_move, 6, null),
		new(GameAI.ai_move, 4, null)
	};

	private static readonly mmove_t mutant_move_pain2 =
		new(M_Mutant.FRAME_pain201, M_Mutant.FRAME_pain206, M_Mutant.mutant_frames_pain2, M_Mutant.mutant_run);

	private static readonly mframe_t[] mutant_frames_pain3 =
	{
		new(GameAI.ai_move, -22, null),
		new(GameAI.ai_move, 3, null),
		new(GameAI.ai_move, 3, null),
		new(GameAI.ai_move, 2, null),
		new(GameAI.ai_move, 1, null),
		new(GameAI.ai_move, 1, null),
		new(GameAI.ai_move, 6, null),
		new(GameAI.ai_move, 3, null),
		new(GameAI.ai_move, 2, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 1, null)
	};

	private static readonly mmove_t mutant_move_pain3 =
		new(M_Mutant.FRAME_pain301, M_Mutant.FRAME_pain311, M_Mutant.mutant_frames_pain3, M_Mutant.mutant_run);

	private static readonly EntPainAdapter mutant_pain = new("mutant_pain", (self, other, kick, damage) =>
	{
		float r;

		if (self.health < self.max_health / 2)
			self.s.skinnum = 1;

		if (GameBase.level.time < self.pain_debounce_time)
			return;

		self.pain_debounce_time = GameBase.level.time + 3;

		if (GameBase.skill.value == 3)
			return; // no pain anims in nightmare

		r = Lib.random();

		if (r < 0.33)
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_pain1, 1, Defines.ATTN_NORM, 0);
			self.monsterinfo.currentmove = M_Mutant.mutant_move_pain1;
		}
		else if (r < 0.66)
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_pain2, 1, Defines.ATTN_NORM, 0);
			self.monsterinfo.currentmove = M_Mutant.mutant_move_pain2;
		}
		else
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_pain1, 1, Defines.ATTN_NORM, 0);
			self.monsterinfo.currentmove = M_Mutant.mutant_move_pain3;
		}
	});

	//
	//	DEATH
	//
	private static readonly EntThinkAdapter mutant_dead = new("mutant_dead", self =>
	{
		Math3D.VectorSet(self.mins, -16, -16, -24);
		Math3D.VectorSet(self.maxs, 16, 16, -8);
		self.movetype = Defines.MOVETYPE_TOSS;
		self.svflags |= Defines.SVF_DEADMONSTER;
		GameBase.gi.linkentity(self);

		M.M_FlyCheck.think(self);

		return true;
	});

	private static readonly mframe_t[] mutant_frames_death1 =
	{
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null)
	};

	private static readonly mmove_t mutant_move_death1 =
		new(M_Mutant.FRAME_death101, M_Mutant.FRAME_death109, M_Mutant.mutant_frames_death1, M_Mutant.mutant_dead);

	private static readonly mframe_t[] mutant_frames_death2 =
	{
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null),
		new(GameAI.ai_move, 0, null)
	};

	private static readonly mmove_t mutant_move_death2 =
		new(M_Mutant.FRAME_death201, M_Mutant.FRAME_death210, M_Mutant.mutant_frames_death2, M_Mutant.mutant_dead);

	private static readonly EntDieAdapter mutant_die = new("mutant_die", (self, inflictor, attacker, damage, point) =>
	{
		int n;

		if (self.health <= self.gib_health)
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, GameBase.gi.soundindex("misc/udeath.wav"), 1, Defines.ATTN_NORM, 0);

			for (n = 0; n < 2; n++)
				GameMisc.ThrowGib(self, "models/objects/gibs/bone/tris.md2", damage, Defines.GIB_ORGANIC);

			for (n = 0; n < 4; n++)
				GameMisc.ThrowGib(self, "models/objects/gibs/sm_meat/tris.md2", damage, Defines.GIB_ORGANIC);

			GameMisc.ThrowHead(self, "models/objects/gibs/head2/tris.md2", damage, Defines.GIB_ORGANIC);
			self.deadflag = Defines.DEAD_DEAD;

			return;
		}

		if (self.deadflag == Defines.DEAD_DEAD)
			return;

		GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Mutant.sound_death, 1, Defines.ATTN_NORM, 0);
		self.deadflag = Defines.DEAD_DEAD;
		self.takedamage = Defines.DAMAGE_YES;
		self.s.skinnum = 1;

		if (Lib.random() < 0.5)
			self.monsterinfo.currentmove = M_Mutant.mutant_move_death1;
		else
			self.monsterinfo.currentmove = M_Mutant.mutant_move_death2;
	});

	//
	//	SPAWN
	//

	/*
	 * QUAKED monster_mutant (1 .5 0) (-32 -32 -24) (32 32 32) Ambush
	 * Trigger_Spawn Sight
	 */
	public static EntThinkAdapter SP_monster_mutant = new("SP_monster_mutant", self =>
	{
		if (GameBase.deathmatch.value != 0)
		{
			GameUtil.G_FreeEdict(self);

			return false;
		}

		M_Mutant.sound_swing = GameBase.gi.soundindex("mutant/mutatck1.wav");
		M_Mutant.sound_hit = GameBase.gi.soundindex("mutant/mutatck2.wav");
		M_Mutant.sound_hit2 = GameBase.gi.soundindex("mutant/mutatck3.wav");
		M_Mutant.sound_death = GameBase.gi.soundindex("mutant/mutdeth1.wav");
		M_Mutant.sound_idle = GameBase.gi.soundindex("mutant/mutidle1.wav");
		M_Mutant.sound_pain1 = GameBase.gi.soundindex("mutant/mutpain1.wav");
		M_Mutant.sound_pain2 = GameBase.gi.soundindex("mutant/mutpain2.wav");
		M_Mutant.sound_sight = GameBase.gi.soundindex("mutant/mutsght1.wav");
		M_Mutant.sound_search = GameBase.gi.soundindex("mutant/mutsrch1.wav");
		M_Mutant.sound_step1 = GameBase.gi.soundindex("mutant/step1.wav");
		M_Mutant.sound_step2 = GameBase.gi.soundindex("mutant/step2.wav");
		M_Mutant.sound_step3 = GameBase.gi.soundindex("mutant/step3.wav");
		M_Mutant.sound_thud = GameBase.gi.soundindex("mutant/thud1.wav");

		self.movetype = Defines.MOVETYPE_STEP;
		self.solid = Defines.SOLID_BBOX;
		self.s.modelindex = GameBase.gi.modelindex("models/monsters/mutant/tris.md2");
		Math3D.VectorSet(self.mins, -32, -32, -24);
		Math3D.VectorSet(self.maxs, 32, 32, 48);

		self.health = 300;
		self.gib_health = -120;
		self.mass = 300;

		self.pain = M_Mutant.mutant_pain;
		self.die = M_Mutant.mutant_die;

		self.monsterinfo.stand = M_Mutant.mutant_stand;
		self.monsterinfo.walk = M_Mutant.mutant_walk;
		self.monsterinfo.run = M_Mutant.mutant_run;
		self.monsterinfo.dodge = null;
		self.monsterinfo.attack = M_Mutant.mutant_jump;
		self.monsterinfo.melee = M_Mutant.mutant_melee;
		self.monsterinfo.sight = M_Mutant.mutant_sight;
		self.monsterinfo.search = M_Mutant.mutant_search;
		self.monsterinfo.idle = M_Mutant.mutant_idle;
		self.monsterinfo.checkattack = M_Mutant.mutant_checkattack;

		GameBase.gi.linkentity(self);

		self.monsterinfo.currentmove = M_Mutant.mutant_move_stand;

		self.monsterinfo.scale = M_Mutant.MODEL_SCALE;
		GameAI.walkmonster_start.think(self);

		return true;
	});
}