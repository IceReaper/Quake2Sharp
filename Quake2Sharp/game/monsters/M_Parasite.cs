/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
namespace Quake2Sharp.game.monsters
{
	using adapters;
	using System;
	using types;
	using util;

	public class M_Parasite
	{
		// This file generated by ModelGen - Do NOT Modify
		public static readonly int FRAME_break01 = 0;
		public static readonly int FRAME_break02 = 1;
		public static readonly int FRAME_break03 = 2;
		public static readonly int FRAME_break04 = 3;
		public static readonly int FRAME_break05 = 4;
		public static readonly int FRAME_break06 = 5;
		public static readonly int FRAME_break07 = 6;
		public static readonly int FRAME_break08 = 7;
		public static readonly int FRAME_break09 = 8;
		public static readonly int FRAME_break10 = 9;
		public static readonly int FRAME_break11 = 10;
		public static readonly int FRAME_break12 = 11;
		public static readonly int FRAME_break13 = 12;
		public static readonly int FRAME_break14 = 13;
		public static readonly int FRAME_break15 = 14;
		public static readonly int FRAME_break16 = 15;
		public static readonly int FRAME_break17 = 16;
		public static readonly int FRAME_break18 = 17;
		public static readonly int FRAME_break19 = 18;
		public static readonly int FRAME_break20 = 19;
		public static readonly int FRAME_break21 = 20;
		public static readonly int FRAME_break22 = 21;
		public static readonly int FRAME_break23 = 22;
		public static readonly int FRAME_break24 = 23;
		public static readonly int FRAME_break25 = 24;
		public static readonly int FRAME_break26 = 25;
		public static readonly int FRAME_break27 = 26;
		public static readonly int FRAME_break28 = 27;
		public static readonly int FRAME_break29 = 28;
		public static readonly int FRAME_break30 = 29;
		public static readonly int FRAME_break31 = 30;
		public static readonly int FRAME_break32 = 31;
		public static readonly int FRAME_death101 = 32;
		public static readonly int FRAME_death102 = 33;
		public static readonly int FRAME_death103 = 34;
		public static readonly int FRAME_death104 = 35;
		public static readonly int FRAME_death105 = 36;
		public static readonly int FRAME_death106 = 37;
		public static readonly int FRAME_death107 = 38;
		public static readonly int FRAME_drain01 = 39;
		public static readonly int FRAME_drain02 = 40;
		public static readonly int FRAME_drain03 = 41;
		public static readonly int FRAME_drain04 = 42;
		public static readonly int FRAME_drain05 = 43;
		public static readonly int FRAME_drain06 = 44;
		public static readonly int FRAME_drain07 = 45;
		public static readonly int FRAME_drain08 = 46;
		public static readonly int FRAME_drain09 = 47;
		public static readonly int FRAME_drain10 = 48;
		public static readonly int FRAME_drain11 = 49;
		public static readonly int FRAME_drain12 = 50;
		public static readonly int FRAME_drain13 = 51;
		public static readonly int FRAME_drain14 = 52;
		public static readonly int FRAME_drain15 = 53;
		public static readonly int FRAME_drain16 = 54;
		public static readonly int FRAME_drain17 = 55;
		public static readonly int FRAME_drain18 = 56;
		public static readonly int FRAME_pain101 = 57;
		public static readonly int FRAME_pain102 = 58;
		public static readonly int FRAME_pain103 = 59;
		public static readonly int FRAME_pain104 = 60;
		public static readonly int FRAME_pain105 = 61;
		public static readonly int FRAME_pain106 = 62;
		public static readonly int FRAME_pain107 = 63;
		public static readonly int FRAME_pain108 = 64;
		public static readonly int FRAME_pain109 = 65;
		public static readonly int FRAME_pain110 = 66;
		public static readonly int FRAME_pain111 = 67;
		public static readonly int FRAME_run01 = 68;
		public static readonly int FRAME_run02 = 69;
		public static readonly int FRAME_run03 = 70;
		public static readonly int FRAME_run04 = 71;
		public static readonly int FRAME_run05 = 72;
		public static readonly int FRAME_run06 = 73;
		public static readonly int FRAME_run07 = 74;
		public static readonly int FRAME_run08 = 75;
		public static readonly int FRAME_run09 = 76;
		public static readonly int FRAME_run10 = 77;
		public static readonly int FRAME_run11 = 78;
		public static readonly int FRAME_run12 = 79;
		public static readonly int FRAME_run13 = 80;
		public static readonly int FRAME_run14 = 81;
		public static readonly int FRAME_run15 = 82;
		public static readonly int FRAME_stand01 = 83;
		public static readonly int FRAME_stand02 = 84;
		public static readonly int FRAME_stand03 = 85;
		public static readonly int FRAME_stand04 = 86;
		public static readonly int FRAME_stand05 = 87;
		public static readonly int FRAME_stand06 = 88;
		public static readonly int FRAME_stand07 = 89;
		public static readonly int FRAME_stand08 = 90;
		public static readonly int FRAME_stand09 = 91;
		public static readonly int FRAME_stand10 = 92;
		public static readonly int FRAME_stand11 = 93;
		public static readonly int FRAME_stand12 = 94;
		public static readonly int FRAME_stand13 = 95;
		public static readonly int FRAME_stand14 = 96;
		public static readonly int FRAME_stand15 = 97;
		public static readonly int FRAME_stand16 = 98;
		public static readonly int FRAME_stand17 = 99;
		public static readonly int FRAME_stand18 = 100;
		public static readonly int FRAME_stand19 = 101;
		public static readonly int FRAME_stand20 = 102;
		public static readonly int FRAME_stand21 = 103;
		public static readonly int FRAME_stand22 = 104;
		public static readonly int FRAME_stand23 = 105;
		public static readonly int FRAME_stand24 = 106;
		public static readonly int FRAME_stand25 = 107;
		public static readonly int FRAME_stand26 = 108;
		public static readonly int FRAME_stand27 = 109;
		public static readonly int FRAME_stand28 = 110;
		public static readonly int FRAME_stand29 = 111;
		public static readonly int FRAME_stand30 = 112;
		public static readonly int FRAME_stand31 = 113;
		public static readonly int FRAME_stand32 = 114;
		public static readonly int FRAME_stand33 = 115;
		public static readonly int FRAME_stand34 = 116;
		public static readonly int FRAME_stand35 = 117;
		public static readonly float MODEL_SCALE = 1.000000f;
		private static int sound_pain1;
		private static int sound_pain2;
		private static int sound_die;
		private static int sound_launch;
		private static int sound_impact;
		private static int sound_suck;
		private static int sound_reelin;
		private static int sound_sight;
		private static int sound_tap;
		private static int sound_scratch;
		private static int sound_search;

		private static readonly EntThinkAdapter parasite_launch = new("parasite_launch", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_launch, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly EntThinkAdapter parasite_reel_in = new("parasite_reel_in", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_reelin, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly EntInteractAdapter parasite_sight = new("parasite_sight", (self, other) =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_sight, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly EntThinkAdapter parasite_tap = new("parasite_tap", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_tap, 1, Defines.ATTN_IDLE, 0);

			return true;
		});

		private static readonly EntThinkAdapter parasite_scratch = new("parasite_scratch", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_scratch, 1, Defines.ATTN_IDLE, 0);

			return true;
		});

		private static EntThinkAdapter parasite_search = new("parasite_search", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_search, 1, Defines.ATTN_IDLE, 0);

			return true;
		});

		private static readonly EntThinkAdapter parasite_start_walk = new("parasite_start_walk", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_start_walk;

			return true;
		});

		private static readonly EntThinkAdapter parasite_walk = new("parasite_walk", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_walk;

			return true;
		});

		private static readonly EntThinkAdapter parasite_stand = new("parasite_stand", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_stand;

			return true;
		});

		private static EntThinkAdapter parasite_end_fidget = new("parasite_end_fidget", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_end_fidget;

			return true;
		});

		private static readonly EntThinkAdapter parasite_do_fidget = new("parasite_do_fidget", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_fidget;

			return true;
		});

		private static readonly EntThinkAdapter parasite_refidget = new("parasite_refidget", self =>
		{
			if (Lib.random() <= 0.8)
				self.monsterinfo.currentmove = M_Parasite.parasite_move_fidget;
			else
				self.monsterinfo.currentmove = M_Parasite.parasite_move_end_fidget;

			return true;
		});

		private static readonly EntThinkAdapter parasite_idle = new("parasite_idle", self =>
		{
			self.monsterinfo.currentmove = M_Parasite.parasite_move_start_fidget;

			return true;
		});

		private static readonly EntThinkAdapter parasite_start_run = new("parasite_start_run", self =>
		{
			if ((self.monsterinfo.aiflags & Defines.AI_STAND_GROUND) != 0)
				self.monsterinfo.currentmove = M_Parasite.parasite_move_stand;
			else
				self.monsterinfo.currentmove = M_Parasite.parasite_move_start_run;

			return true;
		});

		private static readonly EntThinkAdapter parasite_run = new("parasite_run", self =>
		{
			if ((self.monsterinfo.aiflags & Defines.AI_STAND_GROUND) != 0)
				self.monsterinfo.currentmove = M_Parasite.parasite_move_stand;
			else
				self.monsterinfo.currentmove = M_Parasite.parasite_move_run;

			return true;
		});

		private static readonly mframe_t[] parasite_frames_start_fidget =
		{
			new(GameAI.ai_stand, 0, null), new(GameAI.ai_stand, 0, null), new(GameAI.ai_stand, 0, null), new(GameAI.ai_stand, 0, null)
		};

		private static readonly mmove_t parasite_move_start_fidget =
			new(M_Parasite.FRAME_stand18, M_Parasite.FRAME_stand21, M_Parasite.parasite_frames_start_fidget, M_Parasite.parasite_do_fidget);

		private static readonly mframe_t[] parasite_frames_fidget =
		{
			new(GameAI.ai_stand, 0, M_Parasite.parasite_scratch),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_scratch),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null)
		};

		private static readonly mmove_t parasite_move_fidget =
			new(M_Parasite.FRAME_stand22, M_Parasite.FRAME_stand27, M_Parasite.parasite_frames_fidget, M_Parasite.parasite_refidget);

		private static readonly mframe_t[] parasite_frames_end_fidget =
		{
			new(GameAI.ai_stand, 0, M_Parasite.parasite_scratch),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null)
		};

		private static readonly mmove_t parasite_move_end_fidget =
			new(M_Parasite.FRAME_stand28, M_Parasite.FRAME_stand35, M_Parasite.parasite_frames_end_fidget, M_Parasite.parasite_stand);

		private static readonly mframe_t[] parasite_frames_stand =
		{
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, M_Parasite.parasite_tap)
		};

		private static readonly mmove_t parasite_move_stand =
			new(M_Parasite.FRAME_stand01, M_Parasite.FRAME_stand17, M_Parasite.parasite_frames_stand, M_Parasite.parasite_stand);

		private static readonly mframe_t[] parasite_frames_run =
		{
			new(GameAI.ai_run, 30, null),
			new(GameAI.ai_run, 30, null),
			new(GameAI.ai_run, 22, null),
			new(GameAI.ai_run, 19, null),
			new(GameAI.ai_run, 24, null),
			new(GameAI.ai_run, 28, null),
			new(GameAI.ai_run, 25, null)
		};

		private static readonly mmove_t parasite_move_run = new(M_Parasite.FRAME_run03, M_Parasite.FRAME_run09, M_Parasite.parasite_frames_run, null);
		private static readonly mframe_t[] parasite_frames_start_run = { new(GameAI.ai_run, 0, null), new(GameAI.ai_run, 30, null) };

		private static readonly mmove_t parasite_move_start_run =
			new(M_Parasite.FRAME_run01, M_Parasite.FRAME_run02, M_Parasite.parasite_frames_start_run, M_Parasite.parasite_run);

		private static readonly mframe_t[] parasite_frames_stop_run =
		{
			new(GameAI.ai_run, 20, null),
			new(GameAI.ai_run, 20, null),
			new(GameAI.ai_run, 12, null),
			new(GameAI.ai_run, 10, null),
			new(GameAI.ai_run, 0, null),
			new(GameAI.ai_run, 0, null)
		};

		private static mmove_t parasite_move_stop_run = new(M_Parasite.FRAME_run10, M_Parasite.FRAME_run15, M_Parasite.parasite_frames_stop_run, null);

		private static readonly mframe_t[] parasite_frames_walk =
		{
			new(GameAI.ai_walk, 30, null),
			new(GameAI.ai_walk, 30, null),
			new(GameAI.ai_walk, 22, null),
			new(GameAI.ai_walk, 19, null),
			new(GameAI.ai_walk, 24, null),
			new(GameAI.ai_walk, 28, null),
			new(GameAI.ai_walk, 25, null)
		};

		private static readonly mmove_t parasite_move_walk =
			new(M_Parasite.FRAME_run03, M_Parasite.FRAME_run09, M_Parasite.parasite_frames_walk, M_Parasite.parasite_walk);

		private static readonly mframe_t[] parasite_frames_start_walk = { new(GameAI.ai_walk, 0, null), new(GameAI.ai_walk, 30, M_Parasite.parasite_walk) };

		private static readonly mmove_t parasite_move_start_walk =
			new(M_Parasite.FRAME_run01, M_Parasite.FRAME_run02, M_Parasite.parasite_frames_start_walk, null);

		private static readonly mframe_t[] parasite_frames_stop_walk =
		{
			new(GameAI.ai_walk, 20, null),
			new(GameAI.ai_walk, 20, null),
			new(GameAI.ai_walk, 12, null),
			new(GameAI.ai_walk, 10, null),
			new(GameAI.ai_walk, 0, null),
			new(GameAI.ai_walk, 0, null)
		};

		private static mmove_t parasite_move_stop_walk = new(M_Parasite.FRAME_run10, M_Parasite.FRAME_run15, M_Parasite.parasite_frames_stop_walk, null);

		private static readonly mframe_t[] parasite_frames_pain1 =
		{
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 6, null),
			new(GameAI.ai_move, 16, null),
			new(GameAI.ai_move, -6, null),
			new(GameAI.ai_move, -7, null),
			new(GameAI.ai_move, 0, null)
		};

		private static readonly mmove_t parasite_move_pain1 =
			new(M_Parasite.FRAME_pain101, M_Parasite.FRAME_pain111, M_Parasite.parasite_frames_pain1, M_Parasite.parasite_start_run);

		private static readonly EntPainAdapter parasite_pain = new("parasite_pain", (self, other, kick, damage) =>
		{
			if (self.health < self.max_health / 2)
				self.s.skinnum = 1;

			if (GameBase.level.time < self.pain_debounce_time)
				return;

			self.pain_debounce_time = GameBase.level.time + 3;

			if (GameBase.skill.value == 3)
				return; // no pain anims in nightmare

			if (Lib.random() < 0.5)
				GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Parasite.sound_pain1, 1, Defines.ATTN_NORM, 0);
			else
				GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Parasite.sound_pain2, 1, Defines.ATTN_NORM, 0);

			self.monsterinfo.currentmove = M_Parasite.parasite_move_pain1;
		});

		private static readonly EntThinkAdapter parasite_drain_attack = new("parasite_drain_attack", self =>
		{
			float[] offset = { 0, 0, 0 }, start = { 0, 0, 0 }, f = { 0, 0, 0 }, r = { 0, 0, 0 }, end = { 0, 0, 0 }, dir = { 0, 0, 0 };
			trace_t tr;
			int damage;

			Math3D.AngleVectors(self.s.angles, f, r, null);
			Math3D.VectorSet(offset, 24, 0, 6);
			Math3D.G_ProjectSource(self.s.origin, offset, f, r, start);

			Math3D.VectorCopy(self.enemy.s.origin, end);

			if (!M_Parasite.parasite_drain_attack_ok(start, end))
			{
				end[2] = self.enemy.s.origin[2] + self.enemy.maxs[2] - 8;

				if (!M_Parasite.parasite_drain_attack_ok(start, end))
				{
					end[2] = self.enemy.s.origin[2] + self.enemy.mins[2] + 8;

					if (!M_Parasite.parasite_drain_attack_ok(start, end))
						return true;
				}
			}

			Math3D.VectorCopy(self.enemy.s.origin, end);

			tr = GameBase.gi.trace(start, null, null, end, self, Defines.MASK_SHOT);

			if (tr.ent != self.enemy)
				return true;

			if (self.s.frame == M_Parasite.FRAME_drain03)
			{
				damage = 5;
				GameBase.gi.sound(self.enemy, Defines.CHAN_AUTO, M_Parasite.sound_impact, 1, Defines.ATTN_NORM, 0);
			}
			else
			{
				if (self.s.frame == M_Parasite.FRAME_drain04)
					GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Parasite.sound_suck, 1, Defines.ATTN_NORM, 0);

				damage = 2;
			}

			GameBase.gi.WriteByte(Defines.svc_temp_entity);
			GameBase.gi.WriteByte(Defines.TE_PARASITE_ATTACK);

			//gi.WriteShort(self - g_edicts);
			GameBase.gi.WriteShort(self.index);
			GameBase.gi.WritePosition(start);
			GameBase.gi.WritePosition(end);
			GameBase.gi.multicast(self.s.origin, Defines.MULTICAST_PVS);

			Math3D.VectorSubtract(start, end, dir);

			GameCombat.T_Damage(
				self.enemy,
				self,
				self,
				dir,
				self.enemy.s.origin,
				Globals.vec3_origin,
				damage,
				0,
				Defines.DAMAGE_NO_KNOCKBACK,
				Defines.MOD_UNKNOWN
			);

			return true;
		});

		private static readonly mframe_t[] parasite_frames_drain =
		{
			new(GameAI.ai_charge, 0, M_Parasite.parasite_launch),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 15, M_Parasite.parasite_drain_attack),

			// Target hits)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, -2, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, -2, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, -3, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, -2, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, -1, M_Parasite.parasite_drain_attack), // drain)
			new(GameAI.ai_charge, 0, M_Parasite.parasite_reel_in), // let go)
			new(GameAI.ai_charge, -2, null),
			new(GameAI.ai_charge, -2, null),
			new(GameAI.ai_charge, -3, null),
			new(GameAI.ai_charge, 0, null)
		};

		private static readonly mmove_t parasite_move_drain =
			new(M_Parasite.FRAME_drain01, M_Parasite.FRAME_drain18, M_Parasite.parasite_frames_drain, M_Parasite.parasite_start_run);

		private static readonly mframe_t[] parasite_frames_break =
		{
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, -3, null),
			new(GameAI.ai_charge, 1, null),
			new(GameAI.ai_charge, 2, null),
			new(GameAI.ai_charge, -3, null),
			new(GameAI.ai_charge, 1, null),
			new(GameAI.ai_charge, 1, null),
			new(GameAI.ai_charge, 3, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, -18, null),
			new(GameAI.ai_charge, 3, null),
			new(GameAI.ai_charge, 9, null),
			new(GameAI.ai_charge, 6, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, -18, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 8, null),
			new(GameAI.ai_charge, 9, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, -18, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			/* airborne */
			new(GameAI.ai_charge, 0, null), /* slides */
			new(GameAI.ai_charge, 0, null), /* slides */
			new(GameAI.ai_charge, 0, null), /* slides */
			new(GameAI.ai_charge, 0, null), /* slides */
			new(GameAI.ai_charge, 4, null),
			new(GameAI.ai_charge, 11, null),
			new(GameAI.ai_charge, -2, null),
			new(GameAI.ai_charge, -5, null),
			new(GameAI.ai_charge, 1, null)
		};

		private static mmove_t parasite_move_break =
			new(M_Parasite.FRAME_break01, M_Parasite.FRAME_break32, M_Parasite.parasite_frames_break, M_Parasite.parasite_start_run);

		/*
		 * === Break Stuff Ends ===
		 */

		private static readonly EntThinkAdapter parasite_attack = new("parasite_attack", self =>
		{
			//	if (random() <= 0.2)
			//		self.monsterinfo.currentmove = &parasite_move_break;
			//	else
			self.monsterinfo.currentmove = M_Parasite.parasite_move_drain;

			return true;
		});

		/*
		 * === Death Stuff Starts ===
		 */

		private static readonly EntThinkAdapter parasite_dead = new("parasite_dead", self =>
		{
			Math3D.VectorSet(self.mins, -16, -16, -24);
			Math3D.VectorSet(self.maxs, 16, 16, -8);
			self.movetype = Defines.MOVETYPE_TOSS;
			self.svflags |= Defines.SVF_DEADMONSTER;
			self.nextthink = 0;
			GameBase.gi.linkentity(self);

			return true;
		});

		private static readonly mframe_t[] parasite_frames_death =
		{
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null)
		};

		private static readonly mmove_t parasite_move_death =
			new(M_Parasite.FRAME_death101, M_Parasite.FRAME_death107, M_Parasite.parasite_frames_death, M_Parasite.parasite_dead);

		private static readonly EntDieAdapter parasite_die = new("parasite_die", (self, inflictor, attacker, damage, point) =>
		{
			int n;

			// check for gib
			if (self.health <= self.gib_health)
			{
				GameBase.gi.sound(self, Defines.CHAN_VOICE, GameBase.gi.soundindex("misc/udeath.wav"), 1, Defines.ATTN_NORM, 0);

				for (n = 0; n < 2; n++)
					GameMisc.ThrowGib(self, "models/objects/gibs/bone/tris.md2", damage, Defines.GIB_ORGANIC);

				for (n = 0; n < 4; n++)
					GameMisc.ThrowGib(self, "models/objects/gibs/sm_meat/tris.md2", damage, Defines.GIB_ORGANIC);

				GameMisc.ThrowHead(self, "models/objects/gibs/head2/tris.md2", damage, Defines.GIB_ORGANIC);
				self.deadflag = Defines.DEAD_DEAD;

				return;
			}

			if (self.deadflag == Defines.DEAD_DEAD)
				return;

			// regular death
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Parasite.sound_die, 1, Defines.ATTN_NORM, 0);
			self.deadflag = Defines.DEAD_DEAD;
			self.takedamage = Defines.DAMAGE_YES;
			self.monsterinfo.currentmove = M_Parasite.parasite_move_death;
		});

		/*
		 * === End Death Stuff ===
		 */
		/*
		 * QUAKED monster_parasite (1 .5 0) (-16 -16 -24) (16 16 32) Ambush
		 * Trigger_Spawn Sight
		 */

		public static EntThinkAdapter SP_monster_parasite = new("SP_monster_parasite", self =>
		{
			if (GameBase.deathmatch.value != 0)
			{
				GameUtil.G_FreeEdict(self);

				return true;
			}

			M_Parasite.sound_pain1 = GameBase.gi.soundindex("parasite/parpain1.wav");
			M_Parasite.sound_pain2 = GameBase.gi.soundindex("parasite/parpain2.wav");
			M_Parasite.sound_die = GameBase.gi.soundindex("parasite/pardeth1.wav");
			M_Parasite.sound_launch = GameBase.gi.soundindex("parasite/paratck1.wav");
			M_Parasite.sound_impact = GameBase.gi.soundindex("parasite/paratck2.wav");
			M_Parasite.sound_suck = GameBase.gi.soundindex("parasite/paratck3.wav");
			M_Parasite.sound_reelin = GameBase.gi.soundindex("parasite/paratck4.wav");
			M_Parasite.sound_sight = GameBase.gi.soundindex("parasite/parsght1.wav");
			M_Parasite.sound_tap = GameBase.gi.soundindex("parasite/paridle1.wav");
			M_Parasite.sound_scratch = GameBase.gi.soundindex("parasite/paridle2.wav");
			M_Parasite.sound_search = GameBase.gi.soundindex("parasite/parsrch1.wav");

			self.s.modelindex = GameBase.gi.modelindex("models/monsters/parasite/tris.md2");
			Math3D.VectorSet(self.mins, -16, -16, -24);
			Math3D.VectorSet(self.maxs, 16, 16, 24);
			self.movetype = Defines.MOVETYPE_STEP;
			self.solid = Defines.SOLID_BBOX;

			self.health = 175;
			self.gib_health = -50;
			self.mass = 250;

			self.pain = M_Parasite.parasite_pain;
			self.die = M_Parasite.parasite_die;

			self.monsterinfo.stand = M_Parasite.parasite_stand;
			self.monsterinfo.walk = M_Parasite.parasite_start_walk;
			self.monsterinfo.run = M_Parasite.parasite_start_run;
			self.monsterinfo.attack = M_Parasite.parasite_attack;
			self.monsterinfo.sight = M_Parasite.parasite_sight;
			self.monsterinfo.idle = M_Parasite.parasite_idle;

			GameBase.gi.linkentity(self);

			self.monsterinfo.currentmove = M_Parasite.parasite_move_stand;
			self.monsterinfo.scale = M_Parasite.MODEL_SCALE;

			GameAI.walkmonster_start.think(self);

			return true;
		});

		private static bool parasite_drain_attack_ok(float[] start, float[] end)
		{
			float[] dir = { 0, 0, 0 }, angles = { 0, 0, 0 };

			// check for max distance
			Math3D.VectorSubtract(start, end, dir);

			if (Math3D.VectorLength(dir) > 256)
				return false;

			// check for min/max pitch
			Math3D.vectoangles(dir, angles);

			if (angles[0] < -180)
				angles[0] += 360;

			if (Math.Abs(angles[0]) > 30)
				return false;

			return true;
		}
	}
}
