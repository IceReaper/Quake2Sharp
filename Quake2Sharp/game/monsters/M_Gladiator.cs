/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
namespace Quake2Sharp.game.monsters
{
	using adapters;
	using types;
	using util;

	public class M_Gladiator
	{
		//	This file generated by ModelGen - Do NOT Modify
		public static readonly int FRAME_stand1 = 0;
		public static readonly int FRAME_stand2 = 1;
		public static readonly int FRAME_stand3 = 2;
		public static readonly int FRAME_stand4 = 3;
		public static readonly int FRAME_stand5 = 4;
		public static readonly int FRAME_stand6 = 5;
		public static readonly int FRAME_stand7 = 6;
		public static readonly int FRAME_walk1 = 7;
		public static readonly int FRAME_walk2 = 8;
		public static readonly int FRAME_walk3 = 9;
		public static readonly int FRAME_walk4 = 10;
		public static readonly int FRAME_walk5 = 11;
		public static readonly int FRAME_walk6 = 12;
		public static readonly int FRAME_walk7 = 13;
		public static readonly int FRAME_walk8 = 14;
		public static readonly int FRAME_walk9 = 15;
		public static readonly int FRAME_walk10 = 16;
		public static readonly int FRAME_walk11 = 17;
		public static readonly int FRAME_walk12 = 18;
		public static readonly int FRAME_walk13 = 19;
		public static readonly int FRAME_walk14 = 20;
		public static readonly int FRAME_walk15 = 21;
		public static readonly int FRAME_walk16 = 22;
		public static readonly int FRAME_run1 = 23;
		public static readonly int FRAME_run2 = 24;
		public static readonly int FRAME_run3 = 25;
		public static readonly int FRAME_run4 = 26;
		public static readonly int FRAME_run5 = 27;
		public static readonly int FRAME_run6 = 28;
		public static readonly int FRAME_melee1 = 29;
		public static readonly int FRAME_melee2 = 30;
		public static readonly int FRAME_melee3 = 31;
		public static readonly int FRAME_melee4 = 32;
		public static readonly int FRAME_melee5 = 33;
		public static readonly int FRAME_melee6 = 34;
		public static readonly int FRAME_melee7 = 35;
		public static readonly int FRAME_melee8 = 36;
		public static readonly int FRAME_melee9 = 37;
		public static readonly int FRAME_melee10 = 38;
		public static readonly int FRAME_melee11 = 39;
		public static readonly int FRAME_melee12 = 40;
		public static readonly int FRAME_melee13 = 41;
		public static readonly int FRAME_melee14 = 42;
		public static readonly int FRAME_melee15 = 43;
		public static readonly int FRAME_melee16 = 44;
		public static readonly int FRAME_melee17 = 45;
		public static readonly int FRAME_attack1 = 46;
		public static readonly int FRAME_attack2 = 47;
		public static readonly int FRAME_attack3 = 48;
		public static readonly int FRAME_attack4 = 49;
		public static readonly int FRAME_attack5 = 50;
		public static readonly int FRAME_attack6 = 51;
		public static readonly int FRAME_attack7 = 52;
		public static readonly int FRAME_attack8 = 53;
		public static readonly int FRAME_attack9 = 54;
		public static readonly int FRAME_pain1 = 55;
		public static readonly int FRAME_pain2 = 56;
		public static readonly int FRAME_pain3 = 57;
		public static readonly int FRAME_pain4 = 58;
		public static readonly int FRAME_pain5 = 59;
		public static readonly int FRAME_pain6 = 60;
		public static readonly int FRAME_death1 = 61;
		public static readonly int FRAME_death2 = 62;
		public static readonly int FRAME_death3 = 63;
		public static readonly int FRAME_death4 = 64;
		public static readonly int FRAME_death5 = 65;
		public static readonly int FRAME_death6 = 66;
		public static readonly int FRAME_death7 = 67;
		public static readonly int FRAME_death8 = 68;
		public static readonly int FRAME_death9 = 69;
		public static readonly int FRAME_death10 = 70;
		public static readonly int FRAME_death11 = 71;
		public static readonly int FRAME_death12 = 72;
		public static readonly int FRAME_death13 = 73;
		public static readonly int FRAME_death14 = 74;
		public static readonly int FRAME_death15 = 75;
		public static readonly int FRAME_death16 = 76;
		public static readonly int FRAME_death17 = 77;
		public static readonly int FRAME_death18 = 78;
		public static readonly int FRAME_death19 = 79;
		public static readonly int FRAME_death20 = 80;
		public static readonly int FRAME_death21 = 81;
		public static readonly int FRAME_death22 = 82;
		public static readonly int FRAME_painup1 = 83;
		public static readonly int FRAME_painup2 = 84;
		public static readonly int FRAME_painup3 = 85;
		public static readonly int FRAME_painup4 = 86;
		public static readonly int FRAME_painup5 = 87;
		public static readonly int FRAME_painup6 = 88;
		public static readonly int FRAME_painup7 = 89;
		public static readonly float MODEL_SCALE = 1.000000f;
		private static int sound_pain1;
		private static int sound_pain2;
		private static int sound_die;
		private static int sound_gun;
		private static int sound_cleaver_swing;
		private static int sound_cleaver_hit;
		private static int sound_cleaver_miss;
		private static int sound_idle;
		private static int sound_search;
		private static int sound_sight;

		private static readonly EntThinkAdapter gladiator_idle = new("gladiator_idle", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_idle, 1, Defines.ATTN_IDLE, 0);

			return true;
		});

		private static readonly EntInteractAdapter gladiator_sight = new("gladiator_sight", (self, other) =>
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_sight, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly EntThinkAdapter gladiator_search = new("gladiator_search", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_search, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly EntThinkAdapter gladiator_cleaver_swing = new("gladiator_cleaver_swing", self =>
		{
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Gladiator.sound_cleaver_swing, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_stand =
		{
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null),
			new(GameAI.ai_stand, 0, null)
		};

		private static readonly mmove_t gladiator_move_stand =
			new(M_Gladiator.FRAME_stand1, M_Gladiator.FRAME_stand7, M_Gladiator.gladiator_frames_stand, null);

		private static readonly EntThinkAdapter gladiator_stand = new("gladiator_stand", self =>
		{
			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_stand;

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_walk =
		{
			new(GameAI.ai_walk, 15, null),
			new(GameAI.ai_walk, 7, null),
			new(GameAI.ai_walk, 6, null),
			new(GameAI.ai_walk, 5, null),
			new(GameAI.ai_walk, 2, null),
			new(GameAI.ai_walk, 0, null),
			new(GameAI.ai_walk, 2, null),
			new(GameAI.ai_walk, 8, null),
			new(GameAI.ai_walk, 12, null),
			new(GameAI.ai_walk, 8, null),
			new(GameAI.ai_walk, 5, null),
			new(GameAI.ai_walk, 5, null),
			new(GameAI.ai_walk, 2, null),
			new(GameAI.ai_walk, 2, null),
			new(GameAI.ai_walk, 1, null),
			new(GameAI.ai_walk, 8, null)
		};

		private static readonly mmove_t gladiator_move_walk = new(M_Gladiator.FRAME_walk1, M_Gladiator.FRAME_walk16, M_Gladiator.gladiator_frames_walk, null);

		private static readonly EntThinkAdapter gladiator_walk = new("gladiator_walk", self =>
		{
			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_walk;

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_run =
		{
			new(GameAI.ai_run, 23, null),
			new(GameAI.ai_run, 14, null),
			new(GameAI.ai_run, 14, null),
			new(GameAI.ai_run, 21, null),
			new(GameAI.ai_run, 12, null),
			new(GameAI.ai_run, 13, null)
		};

		private static readonly mmove_t gladiator_move_run = new(M_Gladiator.FRAME_run1, M_Gladiator.FRAME_run6, M_Gladiator.gladiator_frames_run, null);

		private static readonly EntThinkAdapter gladiator_run = new("gladiator_run", self =>
		{
			if ((self.monsterinfo.aiflags & Defines.AI_STAND_GROUND) != 0)
				self.monsterinfo.currentmove = M_Gladiator.gladiator_move_stand;
			else
				self.monsterinfo.currentmove = M_Gladiator.gladiator_move_run;

			return true;
		});

		private static readonly EntThinkAdapter GaldiatorMelee = new("GaldiatorMelee", self =>
		{
			float[] aim = { 0, 0, 0 };

			Math3D.VectorSet(aim, Defines.MELEE_DISTANCE, self.mins[0], -4);

			if (GameWeapon.fire_hit(self, aim, 20 + Lib.rand() % 5, 300))
				GameBase.gi.sound(self, Defines.CHAN_AUTO, M_Gladiator.sound_cleaver_hit, 1, Defines.ATTN_NORM, 0);
			else
				GameBase.gi.sound(self, Defines.CHAN_AUTO, M_Gladiator.sound_cleaver_miss, 1, Defines.ATTN_NORM, 0);

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_attack_melee =
		{
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, M_Gladiator.gladiator_cleaver_swing),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, M_Gladiator.GaldiatorMelee),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, M_Gladiator.gladiator_cleaver_swing),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, M_Gladiator.GaldiatorMelee),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null)
		};

		private static readonly mmove_t gladiator_move_attack_melee =
			new(M_Gladiator.FRAME_melee1, M_Gladiator.FRAME_melee17, M_Gladiator.gladiator_frames_attack_melee, M_Gladiator.gladiator_run);

		private static readonly EntThinkAdapter gladiator_melee = new("gladiator_melee", self =>
		{
			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_attack_melee;

			return true;
		});

		private static readonly EntThinkAdapter GladiatorGun = new("GladiatorGun", self =>
		{
			float[] start = { 0, 0, 0 };

			float[] dir = { 0, 0, 0 };
			float[] forward = { 0, 0, 0 }, right = { 0, 0, 0 };

			Math3D.AngleVectors(self.s.angles, forward, right, null);
			Math3D.G_ProjectSource(self.s.origin, M_Flash.monster_flash_offset[Defines.MZ2_GLADIATOR_RAILGUN_1], forward, right, start);

			// calc direction to where we targted
			Math3D.VectorSubtract(self.pos1, start, dir);
			Math3D.VectorNormalize(dir);

			Monster.monster_fire_railgun(self, start, dir, 50, 100, Defines.MZ2_GLADIATOR_RAILGUN_1);

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_attack_gun =
		{
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, M_Gladiator.GladiatorGun),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null),
			new(GameAI.ai_charge, 0, null)
		};

		private static readonly mmove_t gladiator_move_attack_gun =
			new(M_Gladiator.FRAME_attack1, M_Gladiator.FRAME_attack9, M_Gladiator.gladiator_frames_attack_gun, M_Gladiator.gladiator_run);

		private static readonly EntThinkAdapter gladiator_attack = new("gladiator_attack", self =>
		{
			float range;
			float[] v = { 0, 0, 0 };

			// a small safe zone
			Math3D.VectorSubtract(self.s.origin, self.enemy.s.origin, v);
			range = Math3D.VectorLength(v);

			if (range <= Defines.MELEE_DISTANCE + 32)
				return true;

			// charge up the railgun
			GameBase.gi.sound(self, Defines.CHAN_WEAPON, M_Gladiator.sound_gun, 1, Defines.ATTN_NORM, 0);
			Math3D.VectorCopy(self.enemy.s.origin, self.pos1);

			//save for aiming the shot
			self.pos1[2] += self.enemy.viewheight;
			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_attack_gun;

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_pain =
		{
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null)
		};

		private static readonly mmove_t gladiator_move_pain =
			new(M_Gladiator.FRAME_pain1, M_Gladiator.FRAME_pain6, M_Gladiator.gladiator_frames_pain, M_Gladiator.gladiator_run);

		private static readonly mframe_t[] gladiator_frames_pain_air =
		{
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null)
		};

		private static readonly mmove_t gladiator_move_pain_air =
			new(M_Gladiator.FRAME_painup1, M_Gladiator.FRAME_painup7, M_Gladiator.gladiator_frames_pain_air, M_Gladiator.gladiator_run);

		private static readonly EntPainAdapter gladiator_pain = new("gladiator_pain", (self, other, kick, damage) =>
		{
			if (self.health < self.max_health / 2)
				self.s.skinnum = 1;

			if (GameBase.level.time < self.pain_debounce_time)
			{
				if (self.velocity[2] > 100 && self.monsterinfo.currentmove == M_Gladiator.gladiator_move_pain)
					self.monsterinfo.currentmove = M_Gladiator.gladiator_move_pain_air;

				return;
			}

			self.pain_debounce_time = GameBase.level.time + 3;

			if (Lib.random() < 0.5)
				GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_pain1, 1, Defines.ATTN_NORM, 0);
			else
				GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_pain2, 1, Defines.ATTN_NORM, 0);

			if (GameBase.skill.value == 3)
				return; // no pain anims in nightmare

			if (self.velocity[2] > 100)
				self.monsterinfo.currentmove = M_Gladiator.gladiator_move_pain_air;
			else
				self.monsterinfo.currentmove = M_Gladiator.gladiator_move_pain;
		});

		private static readonly EntThinkAdapter gladiator_dead = new("gladiator_dead", self =>
		{
			Math3D.VectorSet(self.mins, -16, -16, -24);
			Math3D.VectorSet(self.maxs, 16, 16, -8);
			self.movetype = Defines.MOVETYPE_TOSS;
			self.svflags |= Defines.SVF_DEADMONSTER;
			self.nextthink = 0;
			GameBase.gi.linkentity(self);

			return true;
		});

		private static readonly mframe_t[] gladiator_frames_death =
		{
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null),
			new(GameAI.ai_move, 0, null)
		};

		private static readonly mmove_t gladiator_move_death =
			new(M_Gladiator.FRAME_death1, M_Gladiator.FRAME_death22, M_Gladiator.gladiator_frames_death, M_Gladiator.gladiator_dead);

		private static readonly EntDieAdapter gladiator_die = new("gladiator_die", (self, inflictor, attacker, damage, point) =>
		{
			int n;

			//	check for gib
			if (self.health <= self.gib_health)
			{
				GameBase.gi.sound(self, Defines.CHAN_VOICE, GameBase.gi.soundindex("misc/udeath.wav"), 1, Defines.ATTN_NORM, 0);

				for (n = 0; n < 2; n++)
					GameMisc.ThrowGib(self, "models/objects/gibs/bone/tris.md2", damage, Defines.GIB_ORGANIC);

				for (n = 0; n < 4; n++)
					GameMisc.ThrowGib(self, "models/objects/gibs/sm_meat/tris.md2", damage, Defines.GIB_ORGANIC);

				GameMisc.ThrowHead(self, "models/objects/gibs/head2/tris.md2", damage, Defines.GIB_ORGANIC);
				self.deadflag = Defines.DEAD_DEAD;

				return;
			}

			if (self.deadflag == Defines.DEAD_DEAD)
				return;

			//	regular death
			GameBase.gi.sound(self, Defines.CHAN_VOICE, M_Gladiator.sound_die, 1, Defines.ATTN_NORM, 0);
			self.deadflag = Defines.DEAD_DEAD;
			self.takedamage = Defines.DAMAGE_YES;

			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_death;
		});

		/*
		 * QUAKED monster_gladiator (1 .5 0) (-32 -32 -24) (32 32 64) Ambush
		 * Trigger_Spawn Sight
		 */
		public static void SP_monster_gladiator(edict_t self)
		{
			if (GameBase.deathmatch.value != 0)
			{
				GameUtil.G_FreeEdict(self);

				return;
			}

			M_Gladiator.sound_pain1 = GameBase.gi.soundindex("gladiator/pain.wav");
			M_Gladiator.sound_pain2 = GameBase.gi.soundindex("gladiator/gldpain2.wav");
			M_Gladiator.sound_die = GameBase.gi.soundindex("gladiator/glddeth2.wav");
			M_Gladiator.sound_gun = GameBase.gi.soundindex("gladiator/railgun.wav");
			M_Gladiator.sound_cleaver_swing = GameBase.gi.soundindex("gladiator/melee1.wav");
			M_Gladiator.sound_cleaver_hit = GameBase.gi.soundindex("gladiator/melee2.wav");
			M_Gladiator.sound_cleaver_miss = GameBase.gi.soundindex("gladiator/melee3.wav");
			M_Gladiator.sound_idle = GameBase.gi.soundindex("gladiator/gldidle1.wav");
			M_Gladiator.sound_search = GameBase.gi.soundindex("gladiator/gldsrch1.wav");
			M_Gladiator.sound_sight = GameBase.gi.soundindex("gladiator/sight.wav");

			self.movetype = Defines.MOVETYPE_STEP;
			self.solid = Defines.SOLID_BBOX;
			self.s.modelindex = GameBase.gi.modelindex("models/monsters/gladiatr/tris.md2");
			Math3D.VectorSet(self.mins, -32, -32, -24);
			Math3D.VectorSet(self.maxs, 32, 32, 64);

			self.health = 400;
			self.gib_health = -175;
			self.mass = 400;

			self.pain = M_Gladiator.gladiator_pain;
			self.die = M_Gladiator.gladiator_die;

			self.monsterinfo.stand = M_Gladiator.gladiator_stand;
			self.monsterinfo.walk = M_Gladiator.gladiator_walk;
			self.monsterinfo.run = M_Gladiator.gladiator_run;
			self.monsterinfo.dodge = null;
			self.monsterinfo.attack = M_Gladiator.gladiator_attack;
			self.monsterinfo.melee = M_Gladiator.gladiator_melee;
			self.monsterinfo.sight = M_Gladiator.gladiator_sight;
			self.monsterinfo.idle = M_Gladiator.gladiator_idle;
			self.monsterinfo.search = M_Gladiator.gladiator_search;

			GameBase.gi.linkentity(self);
			self.monsterinfo.currentmove = M_Gladiator.gladiator_move_stand;
			self.monsterinfo.scale = M_Gladiator.MODEL_SCALE;

			GameAI.walkmonster_start.think(self);
		}
	}
}
